from __future__ import annotations

"""Generate a component inventory with coverage and dependency data.

Run from the repository root:

    python scripts/component_inventory.py

The script executes tests with coverage, analyses core components and
writes a Markdown table to ``docs/component_status.md``.
"""

from pathlib import Path
import ast
import json
import subprocess
from dataclasses import dataclass
from typing import Iterable

try:  # pragma: no cover - coverage is optional
    import coverage
except Exception:  # pragma: no cover
    coverage = None

REPO_ROOT = Path(__file__).resolve().parent.parent
DOC_PATH = REPO_ROOT / "docs" / "component_status.md"
# Core modules and directories to inspect
COMPONENT_NAMES = ["vector_memory.py", "rag", "spiral_os", "INANNA_AI", "tests"]


@dataclass
class ComponentInfo:
    path: Path
    description: str
    future_annotations: bool
    dependencies: set[str]
    coverage: float | None


def run_tests_with_coverage() -> dict[str, dict]:
    """Run tests under coverage and return JSON file data."""
    if coverage is None:
        return {}
    cov = coverage.Coverage()
    cov.start()
    subprocess.run(["pytest"], cwd=REPO_ROOT)  # pragma: no cover - external command
    cov.stop()
    cov.save()
    data_file = REPO_ROOT / "coverage.json"
    try:
        cov.json_report(outfile=str(data_file))
        with data_file.open("r", encoding="utf-8") as fh:
            return json.load(fh).get("files", {})
    except Exception:  # pragma: no cover - fallback when report fails
        return {}


def gather_dependencies(module_path: Path, internal: Iterable[str]) -> set[str]:
    deps: set[str] = set()
    files = [module_path] if module_path.is_file() else module_path.rglob("*.py")
    for py_file in files:
        try:
            tree = ast.parse(py_file.read_text(encoding="utf-8"))
        except Exception:  # pragma: no cover - skip unparsable files
            continue
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    deps.add(alias.name.split(".")[0])
            elif isinstance(node, ast.ImportFrom) and node.module:
                deps.add(node.module.split(".")[0])
    return {d for d in deps if d not in internal}


def analyse_component(path: Path, coverage_data: dict[str, dict], internal: set[str]) -> ComponentInfo:
    description = ""
    future = False
    if path.is_file():
        target_files = [path]
        try:
            tree = ast.parse(path.read_text(encoding="utf-8"))
            description = (ast.get_docstring(tree) or "").splitlines()[0]
            future = any(
                isinstance(stmt, ast.ImportFrom)
                and stmt.module == "__future__"
                and any(name.name == "annotations" for name in stmt.names)
                for stmt in tree.body
            )
        except Exception:  # pragma: no cover
            pass
    else:
        target_files = list(path.rglob("*.py"))
        init_file = path / "__init__.py"
        if init_file.exists():
            try:
                tree = ast.parse(init_file.read_text(encoding="utf-8"))
                description = (ast.get_docstring(tree) or "").splitlines()[0]
                future = any(
                    isinstance(stmt, ast.ImportFrom)
                    and stmt.module == "__future__"
                    and any(name.name == "annotations" for name in stmt.names)
                    for stmt in tree.body
                )
            except Exception:  # pragma: no cover
                pass
    deps = gather_dependencies(path, internal)
    files = [p.relative_to(REPO_ROOT).as_posix() for p in target_files]
    covered = total = 0
    for f in files:
        info = coverage_data.get(f)
        if not info:
            continue
        summary = info.get("summary", {})
        covered += summary.get("covered_lines", 0)
        total += summary.get("num_lines", 0)
    coverage_pct = (covered / total * 100) if total else None
    return ComponentInfo(path=path, description=description, future_annotations=future, dependencies=deps, coverage=coverage_pct)


def write_markdown(rows: list[ComponentInfo]) -> None:
    header = "# Component Status\n\nGenerated by `scripts/component_inventory.py`.\n\n"
    table_header = "| Path | Description | Annotations | Dependencies | Test Coverage |\n| --- | --- | --- | --- | --- |\n"
    lines = [header, table_header]
    for row in rows:
        dep_str = ", ".join(sorted(row.dependencies)) if row.dependencies else ""
        cov = f"{row.coverage:.1f}%" if row.coverage is not None else "N/A"
        lines.append(
            f"| `{row.path.relative_to(REPO_ROOT)}` | {row.description} | {'Yes' if row.future_annotations else 'No'} | {dep_str} | {cov} |\n"
        )
    DOC_PATH.write_text("".join(lines), encoding="utf-8")


def main() -> None:
    components = [REPO_ROOT / name for name in COMPONENT_NAMES if (REPO_ROOT / name).exists()]
    coverage_data = run_tests_with_coverage()
    internal_names = {p.name for p in components}
    rows = [analyse_component(p, coverage_data, internal_names) for p in components]
    write_markdown(rows)


if __name__ == "__main__":
    main()
