# Communication Interfaces

This document outlines how external clients interact with the avatar through
various communication channels. The current implementation exposes WebRTC,
Discord, and Telegram interfaces, with additional channels pluggable through the
gateway layer.

Each connector includes a ``__version__`` field for traceability and is tracked
in the [Connector Index](connectors/CONNECTOR_INDEX.md).

## Media Features and Fallbacks

The WebRTC connector can stream three modalities to clients:

1. **Video** – avatar frames generated from ``video_engine.start_stream``
2. **Audio** – WAV chunks produced by ``AvatarAudioTrack``
3. **Data** – arbitrary binary payloads over a data channel

During negotiation the server inspects the client's offer and only attaches
tracks that were requested. When bandwidth or configuration prohibits video or
audio streaming the connector falls back to data-channel messages, ensuring that
text or other payloads can still reach the client.

## Per-Agent Sessions

Multiple agents can negotiate their own WebRTC channels. Clients address the
desired agent in the signalling endpoint paths:

```text
POST /{agent}/offer         # negotiate and receive an answer
POST /{agent}/avatar-audio  # update the agent's lip-sync audio
```

The server's ``AvatarSessionManager`` keeps tracks isolated per agent so that
video and audio updates do not interfere across sessions.

## Signaling Flow

1. **Client connects** – A client creates a WebRTC offer and sends it to the
   signalling server.
2. **MediaSoup negotiation** – The server responds with an answer generated by
   the MediaSoup worker and sets up an SFU router.
3. **Media streaming** – Once negotiation completes, media streams flow through
   the router to the avatar for processing.
4. **Message routing** – Textual messages from any channel are normalised into
   `ChannelMessage` instances and passed to the AI core.

## Authentication

All connectors call ``communication.gateway.authentication.verify_token`` to
enforce token-based access control. Tokens are provided per channel via
environment variables:

- **WebRTC** – Clients include ``Authorization: Bearer <token>`` in requests to
  the signalling endpoints. The token is checked against ``WEBRTC_TOKEN``.
- **Telegram** – The bot token supplied to the connector must match
  ``TELEGRAM_TOKEN`` before messages are forwarded.

Additional channels should expose a token and use ``verify_token`` prior to
calling the ``Gateway``.

## Chat Connectors

Two reference chat connectors bridge external text platforms to the avatar:

- ``tools/bot_discord.py`` – posts messages from Discord channels to the
  ``/glm-command`` endpoint and returns both text and optional synthesized voice
  clips. Configure a bot token via ``DISCORD_BOT_TOKEN`` and launch with
  ``python tools/bot_discord.py``.
- ``communication/telegram_bot.py`` – forwards Telegram chats through the
  ``Gateway``. Set ``TELEGRAM_BOT_TOKEN`` and run
  ``python communication/telegram_bot.py``.

Both connectors expect the tokens to be defined in the environment (or
``secrets.env``) before startup. When running alongside the avatar console they
relay responses back to their respective channels, enabling remote control of
the agent.

## Discord/Telegram Avatar Streaming

The ``connectors/avatar_broadcast.py`` helper forwards rendered avatar frames
to social platforms. It retrieves the active video track for an agent and sends
each frame plus optional heartbeat metadata to:

- ``tools.bot_discord`` for delivery into a Discord channel
- ``tools.bot_telegram`` for delivery into a Telegram chat

Provide the channel or chat identifiers alongside the agent name when invoking
``broadcast``. The function runs asynchronously and mirrors heartbeats so
remote viewers can monitor stream health.

## Adding New Channels

1. Implement an adapter that receives messages from the external service.
2. Normalise incoming payloads to `ChannelMessage` and forward them through the
   `Gateway`.
3. Provide authentication for the new channel and document the expected tokens
   or API keys.
4. Register the adapter in the deployment configuration so that it starts with
   the avatar.
5. Expose a ``__version__`` field and update the connector registry with the
   new version number.

Following this pattern keeps message handling consistent while allowing the
system to expand with minimal changes.

## Chakra-Tagged Signals

All connectors attach a `chakra` field to outbound events. The tag identifies
the originating layer and lets downstream services track signal flow through
the stack. See
[system_blueprint.md](system_blueprint.md#chakra-tagged-signals) and
[blueprint_spine.md](blueprint_spine.md#chakra-tagged-signals) for the
architectural context.

## Heartbeat Propagation

Connectors forward heartbeat pings from the chakra cycle engine to remote
clients and log the return path. Lagging or missing beats surface alignment
issues early and are mirrored in the dashboards described in the system
blueprint.

## Recovery Flows

When a connector misses consecutive heartbeats, it attempts a clean reconnect
and emits a `chakra_down` notice for Nazarick servants. Operators can follow the
full procedure in the
[Recovery Playbook](recovery_playbook.md#nazarick-resuscitation).
