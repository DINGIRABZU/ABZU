# Communication Interfaces

This document outlines how external clients interact with the avatar through
various communication channels. The current implementation exposes WebRTC,
Discord, and Telegram interfaces, with additional channels pluggable through the
gateway layer.

Each connector includes a ``__version__`` field for traceability and is tracked
in the [Connector Index](connectors/CONNECTOR_INDEX.md).

## Connector Matrix

ABZU bridges external and internal services through these connectors. The table
lists their purpose, protocol choice, heartbeat behaviour, and version. See the
[System Blueprint](system_blueprint.md#connector-matrix) for architectural
placement and the [Blueprint Spine](blueprint_spine.md#connector-matrix) for
narrative context. Code paths reside in [connectors/](../connectors/).

| Connector | Purpose | Protocol | Heartbeat (`chakra`, `cycle_count`) | Version |
|-----------|---------|----------|-------------------------------------|---------|
| WebRTC | Real-time browser media stream | API – browsers rely on WebRTC/HTTP | Data channel pings carry the originating `chakra` and current `cycle_count` to remote clients. | 0.3.3 |
| Discord Bot | Community chat bridge | API + MCP – Discord API externally, MCP internally for logging | Publishes `discord` heartbeats on the signal bus and mirrors cycle counts to channels. | 0.3.0 |
| Telegram Bot | Remote chat control | API + MCP – Telegram API externally, MCP internally to unify command dispatch | Emits `telegram` heartbeats and mirrors `cycle_count` when relayed to chats. | 0.1.0 |
| Avatar Broadcast | Stream avatar frames to social platforms | API – social platforms expose HTTP endpoints only | Relays heartbeat events with both fields to social streams. | 0.1.0 |
| Primordials API | Metric bridge to upstream Primordials service | API – external service lacks MCP | Posts metrics tagged with `chakra` and `cycle_count`. | 0.1.1 |
| MCP Gateway Bridge | Demonstrates pure MCP requests for internal models | MCP – showcases full MCP handshake | Uses MCP handshake and propagates `chakra` and `cycle_count` in responses. | 0.1.0 |

## Media Features and Fallbacks

The WebRTC connector can stream three modalities to clients:

1. **Video** – avatar frames generated from ``video_engine.start_stream``
2. **Audio** – WAV chunks produced by ``AvatarAudioTrack``
3. **Data** – arbitrary binary payloads over a data channel

During negotiation the server inspects the client's offer and only attaches
tracks that were requested. When bandwidth or configuration prohibits video or
audio streaming the connector falls back to data-channel messages, ensuring that
text or other payloads can still reach the client.

## Per-Agent Sessions

Multiple agents can negotiate their own WebRTC channels. Clients address the
desired agent in the signalling endpoint paths:

```text
POST /{agent}/offer         # negotiate and receive an answer
POST /{agent}/avatar-audio  # update the agent's lip-sync audio
```

The server's ``AvatarSessionManager`` keeps tracks isolated per agent so that
video and audio updates do not interfere across sessions.

## Signaling Flow

1. **Client connects** – A client creates a WebRTC offer and sends it to the
   signalling server.
2. **MediaSoup negotiation** – The server responds with an answer generated by
   the MediaSoup worker and sets up an SFU router.
3. **Media streaming** – Once negotiation completes, media streams flow through
   the router to the avatar for processing.
4. **Message routing** – Textual messages from any channel are normalised into
   `ChannelMessage` instances and passed to the AI core.

## Authentication

All connectors call ``communication.gateway.authentication.verify_token`` to
enforce token-based access control. Tokens are provided per channel via
environment variables:

- **WebRTC** – Clients include ``Authorization: Bearer <token>`` in requests to
  the signalling endpoints. The token is checked against ``WEBRTC_TOKEN``.
- **Telegram** – The bot token supplied to the connector must match
  ``TELEGRAM_TOKEN`` before messages are forwarded.

Additional channels should expose a token and use ``verify_token`` prior to
calling the ``Gateway``.

## Chat Connectors

Two reference chat connectors bridge external text platforms to the avatar:

- ``tools/bot_discord.py`` (v0.3.0) – posts messages from Discord channels to
  the ``/glm-command`` endpoint and returns both text and optional synthesized
  voice clips. Configure a bot token via ``DISCORD_BOT_TOKEN`` and launch with
  ``python tools/bot_discord.py``. When ``ABZU_USE_MCP=1`` it routes internal
  commands through the MCP gateway.
- ``communication/telegram_bot.py`` (v0.1.0) – forwards Telegram chats through
  the ``Gateway``. Set ``TELEGRAM_BOT_TOKEN`` and run
  ``python communication/telegram_bot.py``. It also honours
  ``ABZU_USE_MCP=1`` for MCP-based command dispatch.

Both connectors expect the tokens to be defined in the environment (or
``secrets.env``) before startup. When running alongside the avatar console they
relay responses back to their respective channels, enabling remote control of
the agent.

## Discord/Telegram Avatar Streaming

The ``connectors/avatar_broadcast.py`` helper (v0.1.0) forwards rendered avatar
frames to social platforms. It retrieves the active video track for an agent
and sends each frame plus optional heartbeat metadata to:

- ``tools.bot_discord`` (v0.3.0) for delivery into a Discord channel
- ``tools.bot_telegram`` (v0.3.0) for delivery into a Telegram chat

Provide the channel or chat identifiers alongside the agent name when invoking
``broadcast``. The function runs asynchronously and mirrors heartbeats so remote
viewers see the current `chakra` and `cycle_count` in each ping.

## Primordials API

`connectors/primordials_api.py` (v0.1.1) posts metrics to the external
Primordials service. Set `PRIMORDIALS_API_URL` to the service endpoint and call
`send_metrics` with heartbeat fields. When `ABZU_USE_MCP=1`,
`connectors/primordials_mcp.py` (v0.1.0) registers context and forwards metrics
through the MCP gateway using `/primordials/metrics`.

## Narrative API

`connectors/narrative_mcp.py` (v0.1.0) logs stories to the narrative service via
the MCP gateway. Use `handshake` to register context and `log_story` to persist
text through `/narrative/story`.

## MCP Gateway Bridge

`connectors/mcp_gateway_example.py` (v0.1.0) demonstrates a pure MCP flow for
internal models. Enable MCP with `ABZU_USE_MCP=1` and point `MCP_GATEWAY_URL`
at the gateway. Use `invoke(model, text)` to reach models, and
`publish_event`/`subscribe_events` to relay chakra-tagged heartbeats across the
signal bus.

## Adding New Channels

1. Implement an adapter that receives messages from the external service.
2. Normalise incoming payloads to `ChannelMessage` and forward them through the
   `Gateway`.
3. Provide authentication for the new channel and document the expected tokens
   or API keys.
4. Register the adapter in the deployment configuration so that it starts with
   the avatar.
5. Expose a ``__version__`` field and update the connector registry with the
   new version number.

Following this pattern keeps message handling consistent while allowing the
system to expand with minimal changes.

## Chakra-Tagged Signals

All connectors attach a `chakra` field to outbound events so downstream
services can track signal flow through the stack. See the connector matrices in
[system_blueprint.md](system_blueprint.md#connector-matrix) and
[blueprint_spine.md](blueprint_spine.md#connector-matrix) for architectural
context.

## Heartbeat Propagation

Connectors forward heartbeat pings from the chakra cycle engine to remote
clients and log the return path. Each ping is wrapped by
``connectors.message_formatter.format_message``, which injects the `chakra`,
`cycle_count`, `version`, and `recovery_url` fields so operators can trace
problems and surface recovery instructions. Lagging or missing beats surface
alignment issues early and are mirrored in the dashboards described in the
[System Blueprint](system_blueprint.md#heartbeat-propagation) and
[Blueprint Spine](blueprint_spine.md#heartbeat-propagation-and-self-healing).

## Recovery Flows

When a connector misses consecutive heartbeats, it attempts a clean reconnect
and emits a `chakra_down` notice for Nazarick servants. Operators can follow the
full procedure in the
[Recovery Playbook](recovery_playbook.md#nazarick-resuscitation).
