# Communication Interfaces

This document outlines how external clients interact with the avatar through
various communication channels. The current implementation exposes WebRTC and
Telegram interfaces, with additional channels pluggable through the gateway
layer.

Each connector includes a ``__version__`` field for traceability and is tracked
in the [Connector Index](connectors/CONNECTOR_INDEX.md).

## Media Features and Fallbacks

The WebRTC connector can stream three modalities to clients:

1. **Video** – avatar frames generated from ``video_engine.start_stream``
2. **Audio** – WAV chunks produced by ``AvatarAudioTrack``
3. **Data** – arbitrary binary payloads over a data channel

During negotiation the server inspects the client's offer and only attaches
tracks that were requested. When bandwidth or configuration prohibits video or
audio streaming the connector falls back to data-channel messages, ensuring that
text or other payloads can still reach the client.

## Per-Agent Sessions

Multiple agents can negotiate their own WebRTC channels. Clients address the
desired agent in the signalling endpoint paths:

```text
POST /{agent}/offer         # negotiate and receive an answer
POST /{agent}/avatar-audio  # update the agent's lip-sync audio
```

The server's ``AvatarSessionManager`` keeps tracks isolated per agent so that
video and audio updates do not interfere across sessions.

## Signaling Flow

1. **Client connects** – A client creates a WebRTC offer and sends it to the
   signalling server.
2. **MediaSoup negotiation** – The server responds with an answer generated by
   the MediaSoup worker and sets up an SFU router.
3. **Media streaming** – Once negotiation completes, media streams flow through
   the router to the avatar for processing.
4. **Message routing** – Textual messages from any channel are normalised into
   `ChannelMessage` instances and passed to the AI core.

## Authentication

All connectors call ``communication.gateway.authentication.verify_token`` to
enforce token-based access control. Tokens are provided per channel via
environment variables:

- **WebRTC** – Clients include ``Authorization: Bearer <token>`` in requests to
  the signalling endpoints. The token is checked against ``WEBRTC_TOKEN``.
- **Telegram** – The bot token supplied to the connector must match
  ``TELEGRAM_TOKEN`` before messages are forwarded.

Additional channels should expose a token and use ``verify_token`` prior to
calling the ``Gateway``.

## Adding New Channels

1. Implement an adapter that receives messages from the external service.
2. Normalise incoming payloads to `ChannelMessage` and forward them through the
   `Gateway`.
3. Provide authentication for the new channel and document the expected tokens
   or API keys.
4. Register the adapter in the deployment configuration so that it starts with
   the avatar.
5. Expose a ``__version__`` field and update the connector registry with the
   new version number.

Following this pattern keeps message handling consistent while allowing the
system to expand with minimal changes.
