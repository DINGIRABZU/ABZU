# Communication Interfaces

This document outlines how external clients interact with the avatar through
various communication channels. The current implementation exposes WebRTC and
Telegram interfaces, with additional channels pluggable through the gateway
layer.

Each connector includes a ``__version__`` field for traceability and is tracked
in the [Connector Index](connectors/CONNECTOR_INDEX.md).

## Signaling Flow

1. **Client connects** – A client creates a WebRTC offer and sends it to the
   signalling server.
2. **MediaSoup negotiation** – The server responds with an answer generated by
   the MediaSoup worker and sets up an SFU router.
3. **Media streaming** – Once negotiation completes, media streams flow through
   the router to the avatar for processing.
4. **Message routing** – Textual messages from any channel are normalised into
   `ChannelMessage` instances and passed to the AI core.

## Authentication

Each channel is responsible for authenticating its users:

- **WebRTC** – Clients must include a JWT in the signalling request. The server
  validates the token before establishing a session.
- **Telegram** – The bot token grants access to the Telegram API. User identity
  is derived from the incoming update's `user_id`.

Gateway integrations should verify credentials before forwarding messages.

## Adding New Channels

1. Implement an adapter that receives messages from the external service.
2. Normalise incoming payloads to `ChannelMessage` and forward them through the
   `Gateway`.
3. Provide authentication for the new channel and document the expected tokens
   or API keys.
4. Register the adapter in the deployment configuration so that it starts with
   the avatar.
5. Expose a ``__version__`` field and update the connector registry with the
   new version number.

Following this pattern keeps message handling consistent while allowing the
system to expand with minimal changes.
