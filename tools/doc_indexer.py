"""Generate an index of Markdown documentation files."""

from __future__ import annotations

__version__ = "0.1.0"

import os
import re
import subprocess
from pathlib import Path
from typing import List, Tuple

ROOT = Path(__file__).resolve().parents[1]
INDEX_FILE = ROOT / "docs" / "INDEX.md"
# Directories to exclude from indexing to avoid processing generated artifacts
EXCLUDED_DIRS = {"node_modules", "dist", "build"}

HEADING_RE = re.compile(r"^#\s+(.*)")
MODULE_RE = re.compile(r"\[.*?\]\(([^)]+\.py)\)")


def collect_markdown_paths() -> List[Path]:
    """Return a sorted list of Markdown file paths under the repository."""
    command = ["find", ".", "-name", "*.md"]
    for d in EXCLUDED_DIRS:
        command.extend(["-not", "-path", f"*/{d}/*"])
    result = subprocess.run(
        command,
        cwd=ROOT,
        capture_output=True,
        text=True,
        check=True,
    )
    paths: List[Path] = []
    for raw in result.stdout.splitlines():
        line = raw.strip()
        if not line:
            continue
        path = (ROOT / Path(line)).resolve()
        if path == INDEX_FILE.resolve():
            continue
        if any(part in EXCLUDED_DIRS for part in path.parts):
            continue
        paths.append(path)
    return sorted(paths)


def parse_markdown(path: Path) -> Tuple[str, str, List[str]]:
    """Extract the title, summary paragraph and related modules from *path*."""
    lines = path.read_text(encoding="utf-8", errors="ignore").splitlines()
    title = path.name
    summary_lines: List[str] = []
    for i, line in enumerate(lines):
        match = HEADING_RE.match(line)
        if match:
            title = match.group(1).strip()
            for body_line in lines[i + 1 :]:
                if body_line.strip() == "":
                    if summary_lines:
                        break
                    continue
                if body_line.startswith("#"):
                    break
                summary_lines.append(body_line.strip())
            break
    summary = " ".join(summary_lines)
    if len(summary) > 120:
        summary = summary[:117].rstrip() + "..."
    modules = sorted(set(MODULE_RE.findall("\n".join(lines))))
    return title, summary, modules


def write_index(entries: List[Tuple[str, str, str, List[str]]]) -> None:
    """Write the collected *entries* to ``docs/INDEX.md``."""
    INDEX_FILE.parent.mkdir(parents=True, exist_ok=True)
    lines = [
        "# Documentation Index",
        "",
        "Generated by `tools/doc_indexer.py`.",
        "",
        "This index excludes `node_modules`, `dist`, and `build` directories.",
        "",
        "Adhere to operator-first principle: pair system changes with operator gains.",
        "",
        "Use `python scripts/verify_doctrine_refs.py` to validate doctrine references.",
        "",
        "| File | Title | Summary | Related Modules |",
        "|------|-------|---------|-----------------|",
    ]
    for rel_path, title, summary, modules in entries:
        modules_text = ", ".join(f"`{m}`" for m in modules) if modules else "-"
        safe_title = title.replace("|", "\\|")
        safe_summary = (summary or "-").replace("|", "\\|")
        safe_modules = modules_text.replace("|", "\\|")
        line = (
            f"| [{rel_path}]({rel_path}) | {safe_title} | "
            f"{safe_summary} | {safe_modules} |"
        )
        lines.append(line)
    lines.append("")
    INDEX_FILE.write_text("\n".join(lines), encoding="utf-8")
    print(f"Wrote index with {len(entries)} entries to {INDEX_FILE}")


def main() -> None:
    """Entry point for CLI execution."""
    paths = collect_markdown_paths()
    entries: List[Tuple[str, str, str, List[str]]] = []
    for path in paths:
        title, summary, modules = parse_markdown(path)
        rel_path = os.path.relpath(path, start=INDEX_FILE.parent)
        entries.append((rel_path, title, summary, modules))
    write_index(entries)


if __name__ == "__main__":  # pragma: no cover - CLI entry
    main()
