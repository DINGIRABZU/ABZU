"""Development cycle orchestrator using lightweight multi-agent workflow.

This module spawns planner, coder and reviewer agents backed by the existing
:class:`~INANNA_AI.glm_integration.GLMIntegration` interface. Agents share a
simple queue for task handoff and persist context using :mod:`vector_memory`.
Every significant step is logged to ``data/interactions.jsonl`` via
:func:`corpus_memory_logging.log_interaction` for later inspection.

The implementation optionally leverages the
`autogen <https://github.com/microsoft/autogen>`_ framework when installed. If
unavailable, the orchestrator still functions with minimal dependencies.
"""

from __future__ import annotations

__version__ = "0.1.0"

import logging
import os
import shutil
import subprocess
import time
from dataclasses import dataclass
from pathlib import Path
from queue import Queue
from typing import Any, Dict, List

from corpus_memory_logging import log_interaction
from INANNA_AI.glm_integration import GLMIntegration
from orchestration_master import AlbedoOrchestrator

try:  # pragma: no cover - optional dependency
    import vector_memory as _vector_memory
except ImportError:  # pragma: no cover - optional dependency
    _vector_memory = None  # type: ignore[assignment]
vector_memory = _vector_memory
"""Optional vector memory subsystem; ``None`` if unavailable."""

try:  # pragma: no cover - optional dependency
    from autogen import AssistantAgent  # type: ignore
except Exception:  # pragma: no cover - optional dependency
    AssistantAgent = None  # type: ignore

logger = logging.getLogger(__name__)


@dataclass
class DevAgent:
    """Base helper for planner, coder and reviewer agents."""

    name: str
    role: str
    glm: GLMIntegration
    objective: str
    queue: Queue[str]
    framework_agent: Any | None = None

    def __post_init__(self) -> None:  # pragma: no cover - depends on autogen
        if AssistantAgent is not None:
            self.framework_agent = AssistantAgent(
                name=self.name, system_message=self.role
            )

    def _context(self, text: str) -> str:
        if vector_memory is None:
            return ""
        hits = vector_memory.search(text, filter={"objective": self.objective})
        return "\n".join(h.get("text", "") for h in hits)

    def _log(self, prompt: str, response: str) -> None:
        if vector_memory is not None:
            vector_memory.add_vector(
                prompt,
                {
                    "agent": self.name,
                    "objective": self.objective,
                    "response": response,
                },
            )
        log_interaction(
            prompt,
            {"agent": self.name, "objective": self.objective},
            {"response": response},
            "ok",
        )

    def _complete(self, prompt: str) -> str:
        logger.debug("%s prompting GLM", self.name)
        return self.glm.complete(prompt)


class Planner(DevAgent):
    """Agent that breaks an objective into actionable steps."""

    def plan(self) -> List[str]:
        prompt = (
            "You are a project planner. Break the objective into short "
            "steps.\n"
            f"Objective: {self.objective}\n"
            f"Context:\n{self._context(self.objective)}"
        )
        response = self._complete(prompt)
        self._log(prompt, response)
        steps = [s.strip("- ") for s in response.splitlines() if s.strip()]
        for step in steps:
            self.queue.put(step)
        return steps


class Coder(DevAgent):
    """Agent that produces code for each planned step."""

    def code(self, task: str) -> str:
        prompt = (
            f"You are a software engineer. Implement the task.\nTask: {task}\n"
            f"Context:\n{self._context(task)}"
        )
        response = self._complete(prompt)
        self._log(prompt, response)
        return response


class Reviewer(DevAgent):
    """Agent that reviews code generated by :class:`Coder`."""

    def review(self, task: str, code: str) -> str:
        prompt = (
            "You are a code reviewer. Provide concise feedback.\n"
            f"Task: {task}\nCode:\n{code}\nContext:\n{self._context(task)}"
        )
        response = self._complete(prompt)
        self._log(prompt, response)
        return response


def _run_tests(repo: Path) -> Dict[str, Any]:
    """Execute ``pytest`` in ``repo`` and return output and status."""
    logger.info("running tests in %s", repo)
    if shutil.which("pytest") is None:
        msg = "pytest not found; skipping tests"
        logger.warning(msg)
        log_interaction(
            "pytest",
            {"agent": "tester"},
            {"output": msg},
            "skip",
        )
        return {"returncode": None, "output": msg}
    proc = subprocess.run(
        ["pytest", "-q"], cwd=repo, capture_output=True, text=True, check=False
    )
    output = proc.stdout + proc.stderr
    log_interaction(
        "pytest",
        {"agent": "tester"},
        {"output": output},
        "ok" if proc.returncode == 0 else "fail",
    )
    return {"returncode": proc.returncode, "output": output}


def _commit(repo: Path, message: str) -> None:
    """Commit current repository state with ``message``."""
    logger.info("committing changes: %s", message)
    subprocess.run(["git", "add", "-A"], cwd=repo, check=False)
    subprocess.run(["git", "commit", "-m", message], cwd=repo, check=False)
    log_interaction(
        "git commit", {"agent": "dev_orchestrator"}, {"message": message}, "ok"
    )


class DevAssistantService:
    """Long-running assistant that monitors logs and schedules dev cycles.

    The service watches a log file for trigger phrases defined in
    ``objectives``. When a trigger is detected the mapped objective is fed to
    :func:`run_dev_cycle`. Results are logged as suggestions to the operator.
    """

    def __init__(
        self,
        *,
        repo: Path,
        log_path: Path,
        objectives: Dict[str, str] | None = None,
        poll_interval: float = 30.0,
        suggestion_path: Path | None = None,
    ) -> None:
        self.repo = repo
        self.log_path = log_path
        self.poll_interval = poll_interval
        self.objectives = objectives or {"FAILED": "repair failing tests"}
        self.logger = logging.getLogger("dev_assistant_service")
        self._stop_path = self.log_path.with_suffix(".stop")
        self.suggestion_path = suggestion_path or self.log_path.with_suffix(
            ".suggestions"
        )

    def _suggest(self, objective: str, result: Dict[str, Any]) -> None:
        plan = result.get("plan") or []
        if plan:
            suggestion = "; ".join(plan)
            self.logger.info("Suggestions for %s: %s", objective, suggestion)
            try:
                timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
                with self.suggestion_path.open(
                    "a",
                    encoding="utf-8",
                ) as fh:
                    fh.write(f"{timestamp}\t{objective}: {suggestion}\n")
            except Exception:  # pragma: no cover - best effort logging
                self.logger.debug(
                    "Failed writing suggestion file",
                    exc_info=True,
                )
            log_interaction(
                "suggestion",
                {"agent": "dev_assistant", "objective": objective},
                {"suggestion": suggestion},
                "ok",
            )
        else:
            self.logger.info("No suggestions produced for %s", objective)
            log_interaction(
                "suggestion",
                {"agent": "dev_assistant", "objective": objective},
                {"suggestion": ""},
                "empty",
            )

    def run_forever(self) -> None:
        """Monitor ``log_path`` until a stop file appears."""
        last_size = 0
        self.logger.info("Watching %s", self.log_path)
        while True:
            if self._stop_path.exists():
                self.logger.info("Stop signal detected; exiting")
                self._stop_path.unlink(missing_ok=True)
                break
            if self.log_path.is_file():
                text = self.log_path.read_text()
                new_text = text[last_size:]
                last_size = len(text)
                for marker, objective in self.objectives.items():
                    if marker in new_text:
                        self.logger.info(
                            "Trigger '%s' found; running objective '%s'",
                            marker,
                            objective,
                        )
                        result = run_dev_cycle(objective, repo=self.repo)
                        self._suggest(objective, result)
            time.sleep(self.poll_interval)


def _glm_from_env(var: str) -> GLMIntegration:
    """Return a :class:`GLMIntegration` using ``var`` as endpoint override."""
    return GLMIntegration(endpoint=os.getenv(var))


def run_dev_cycle(
    objective: str,
    *,
    repo: str | Path | None = None,
    max_iterations: int | None = None,
) -> Dict[str, Any]:
    """Delegate scheduling to :class:`AlbedoOrchestrator`.

    ``objective`` is forwarded to the orchestrator which coordinates planning,
    coding, review, testing and optional commits.
    """

    orchestrator = AlbedoOrchestrator(repo=repo, max_iterations=max_iterations)
    return orchestrator.start(objective)


__all__ = [
    "run_dev_cycle",
    "Planner",
    "Coder",
    "Reviewer",
    "DevAgent",
    "DevAssistantService",
]
