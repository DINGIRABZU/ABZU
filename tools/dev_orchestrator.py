from __future__ import annotations

"""Development cycle orchestrator using lightweight multi-agent workflow.

This module spawns planner, coder and reviewer agents backed by the existing
:class:`~INANNA_AI.glm_integration.GLMIntegration` interface. Agents share a
simple queue for task handoff and persist context using :mod:`vector_memory`.
Every significant step is logged to ``data/interactions.jsonl`` via
:func:`corpus_memory_logging.log_interaction` for later inspection.

The implementation optionally leverages the
`autogen <https://github.com/microsoft/autogen>`_ framework when installed. If
unavailable, the orchestrator still functions with minimal dependencies.
"""

from dataclasses import dataclass
from queue import Queue
from pathlib import Path
import subprocess
from typing import Any, Dict, List
import logging
import os
import time

from corpus_memory_logging import log_interaction
from INANNA_AI.glm_integration import GLMIntegration
import vector_memory

try:  # pragma: no cover - optional dependency
    from autogen import AssistantAgent  # type: ignore
except Exception:  # pragma: no cover - optional dependency
    AssistantAgent = None  # type: ignore

logger = logging.getLogger(__name__)


@dataclass
class DevAgent:
    """Base helper for planner, coder and reviewer agents."""

    name: str
    role: str
    glm: GLMIntegration
    objective: str
    queue: Queue[str]
    framework_agent: Any | None = None

    def __post_init__(self) -> None:  # pragma: no cover - depends on autogen
        if AssistantAgent is not None:
            self.framework_agent = AssistantAgent(
                name=self.name, system_message=self.role
            )

    def _context(self, text: str) -> str:
        hits = vector_memory.search(text, filter={"objective": self.objective})
        return "\n".join(h.get("text", "") for h in hits)

    def _log(self, prompt: str, response: str) -> None:
        vector_memory.add_vector(
            prompt,
            {"agent": self.name, "objective": self.objective, "response": response},
        )
        log_interaction(
            prompt,
            {"agent": self.name, "objective": self.objective},
            {"response": response},
            "ok",
        )

    def _complete(self, prompt: str) -> str:
        logger.debug("%s prompting GLM", self.name)
        return self.glm.complete(prompt)


class Planner(DevAgent):
    """Agent that breaks an objective into actionable steps."""

    def plan(self) -> List[str]:
        prompt = (
            "You are a project planner. Break the objective into short steps.\n"
            f"Objective: {self.objective}\nContext:\n{self._context(self.objective)}"
        )
        response = self._complete(prompt)
        self._log(prompt, response)
        steps = [s.strip("- ") for s in response.splitlines() if s.strip()]
        for step in steps:
            self.queue.put(step)
        return steps


class Coder(DevAgent):
    """Agent that produces code for each planned step."""

    def code(self, task: str) -> str:
        prompt = (
            f"You are a software engineer. Implement the task.\nTask: {task}\n"
            f"Context:\n{self._context(task)}"
        )
        response = self._complete(prompt)
        self._log(prompt, response)
        return response


class Reviewer(DevAgent):
    """Agent that reviews code generated by :class:`Coder`."""

    def review(self, task: str, code: str) -> str:
        prompt = (
            "You are a code reviewer. Provide concise feedback.\n"
            f"Task: {task}\nCode:\n{code}\nContext:\n{self._context(task)}"
        )
        response = self._complete(prompt)
        self._log(prompt, response)
        return response


def _run_tests(repo: Path) -> Dict[str, Any]:
    """Execute ``pytest`` in ``repo`` and return output and status."""
    logger.info("running tests in %s", repo)
    proc = subprocess.run(
        ["pytest", "-q"], cwd=repo, capture_output=True, text=True, check=False
    )
    output = proc.stdout + proc.stderr
    log_interaction(
        "pytest",
        {"agent": "tester"},
        {"output": output},
        "ok" if proc.returncode == 0 else "fail",
    )
    return {"returncode": proc.returncode, "output": output}


def _commit(repo: Path, message: str) -> None:
    """Commit current repository state with ``message``."""
    logger.info("committing changes: %s", message)
    subprocess.run(["git", "add", "-A"], cwd=repo, check=False)
    subprocess.run(["git", "commit", "-m", message], cwd=repo, check=False)
    log_interaction(
        "git commit", {"agent": "dev_orchestrator"}, {"message": message}, "ok"
    )


class DevAssistantService:
    """Long-running assistant that monitors logs and schedules dev cycles.

    The service watches a log file for trigger phrases defined in ``objectives``.
    When a trigger is detected the mapped objective is fed to
    :func:`run_dev_cycle`. Results are logged as suggestions to the operator.
    """

    def __init__(
        self,
        *,
        repo: Path,
        log_path: Path,
        objectives: Dict[str, str] | None = None,
        poll_interval: float = 30.0,
    ) -> None:
        self.repo = repo
        self.log_path = log_path
        self.poll_interval = poll_interval
        self.objectives = objectives or {"FAILED": "repair failing tests"}
        self.logger = logging.getLogger("dev_assistant_service")
        self._stop_path = self.log_path.with_suffix(".stop")

    def _suggest(self, objective: str, result: Dict[str, Any]) -> None:
        plan = result.get("plan") or []
        if plan:
            suggestion = "; ".join(plan)
            self.logger.info("Suggestions for %s: %s", objective, suggestion)
            log_interaction(
                "suggestion",
                {"agent": "dev_assistant", "objective": objective},
                {"suggestion": suggestion},
                "ok",
            )
        else:
            self.logger.info("No suggestions produced for %s", objective)
            log_interaction(
                "suggestion",
                {"agent": "dev_assistant", "objective": objective},
                {"suggestion": ""},
                "empty",
            )

    def run_forever(self) -> None:
        """Monitor ``log_path`` until a stop file appears."""
        last_size = 0
        self.logger.info("Watching %s", self.log_path)
        while True:
            if self._stop_path.exists():
                self.logger.info("Stop signal detected; exiting")
                self._stop_path.unlink(missing_ok=True)
                break
            if self.log_path.is_file():
                text = self.log_path.read_text()
                new_text = text[last_size:]
                last_size = len(text)
                for marker, objective in self.objectives.items():
                    if marker in new_text:
                        self.logger.info(
                            "Trigger '%s' found; running objective '%s'",
                            marker,
                            objective,
                        )
                        result = run_dev_cycle(objective, repo=self.repo)
                        self._suggest(objective, result)
            time.sleep(self.poll_interval)


def _glm_from_env(var: str) -> GLMIntegration:
    """Return a :class:`GLMIntegration` using ``var`` as endpoint override."""
    return GLMIntegration(endpoint=os.getenv(var))


def run_dev_cycle(objective: str, *, repo: str | Path | None = None) -> Dict[str, Any]:
    """Coordinate planning, coding, review, testing and commit for ``objective``."""
    queue: Queue[str] = Queue()
    repo_path = Path(repo) if repo is not None else None

    planner_glm = _glm_from_env("PLANNER_MODEL")
    coder_glm = _glm_from_env("CODER_MODEL")
    reviewer_glm = _glm_from_env("REVIEWER_MODEL")

    planner = Planner("planner", "Plan development tasks", planner_glm, objective, queue)
    coder = Coder("coder", "Write code", coder_glm, objective, queue)
    reviewer = Reviewer("reviewer", "Review code", reviewer_glm, objective, queue)

    plan_steps = planner.plan()
    results: List[Dict[str, str]] = []
    while not queue.empty():
        task = queue.get()
        code = coder.code(task)
        review = reviewer.review(task, code)
        results.append({"task": task, "code": code, "review": review})

    test_result: Dict[str, Any] | None = None
    if repo_path is not None:
        test_result = _run_tests(repo_path)
        if test_result["returncode"] == 0:
            _commit(repo_path, f"Auto commit: {objective}")

    return {
        "objective": objective,
        "plan": plan_steps,
        "results": results,
        "tests": test_result,
    }


__all__ = [
    "run_dev_cycle",
    "Planner",
    "Coder",
    "Reviewer",
    "DevAgent",
    "DevAssistantService",
]

