from __future__ import annotations

"""Development cycle orchestrator using lightweight multi-agent workflow.

This module spawns planner, coder and reviewer agents backed by the existing
:class:`~INANNA_AI.glm_integration.GLMIntegration` interface. Agents share a
simple queue for task handoff and persist context using :mod:`vector_memory`.
Every significant step is logged to ``data/interactions.jsonl`` via
:func:`corpus_memory_logging.log_interaction` for later inspection.

The implementation optionally leverages the
`autogen <https://github.com/microsoft/autogen>`_ framework when installed. If
unavailable, the orchestrator still functions with minimal dependencies.
"""

from dataclasses import dataclass
from queue import Queue
from pathlib import Path
import subprocess
from typing import Any, Dict, List
import logging

from corpus_memory_logging import log_interaction
from INANNA_AI.glm_integration import GLMIntegration
import vector_memory

try:  # pragma: no cover - optional dependency
    from autogen import AssistantAgent  # type: ignore
except Exception:  # pragma: no cover - optional dependency
    AssistantAgent = None  # type: ignore

logger = logging.getLogger(__name__)


@dataclass
class DevAgent:
    """Base helper for planner, coder and reviewer agents."""

    name: str
    role: str
    glm: GLMIntegration
    objective: str
    queue: Queue[str]
    framework_agent: Any | None = None

    def __post_init__(self) -> None:  # pragma: no cover - depends on autogen
        if AssistantAgent is not None:
            self.framework_agent = AssistantAgent(
                name=self.name, system_message=self.role
            )

    def _context(self, text: str) -> str:
        hits = vector_memory.search(text, filter={"objective": self.objective})
        return "\n".join(h.get("text", "") for h in hits)

    def _log(self, prompt: str, response: str) -> None:
        vector_memory.add_vector(
            prompt,
            {"agent": self.name, "objective": self.objective, "response": response},
        )
        log_interaction(
            prompt,
            {"agent": self.name, "objective": self.objective},
            {"response": response},
            "ok",
        )

    def _complete(self, prompt: str) -> str:
        logger.debug("%s prompting GLM", self.name)
        return self.glm.complete(prompt)


class Planner(DevAgent):
    """Agent that breaks an objective into actionable steps."""

    def plan(self) -> List[str]:
        prompt = (
            "You are a project planner. Break the objective into short steps.\n"
            f"Objective: {self.objective}\nContext:\n{self._context(self.objective)}"
        )
        response = self._complete(prompt)
        self._log(prompt, response)
        steps = [s.strip("- ") for s in response.splitlines() if s.strip()]
        for step in steps:
            self.queue.put(step)
        return steps


class Coder(DevAgent):
    """Agent that produces code for each planned step."""

    def code(self, task: str) -> str:
        prompt = (
            f"You are a software engineer. Implement the task.\nTask: {task}\n"
            f"Context:\n{self._context(task)}"
        )
        response = self._complete(prompt)
        self._log(prompt, response)
        return response


class Reviewer(DevAgent):
    """Agent that reviews code generated by :class:`Coder`."""

    def review(self, task: str, code: str) -> str:
        prompt = (
            "You are a code reviewer. Provide concise feedback.\n"
            f"Task: {task}\nCode:\n{code}\nContext:\n{self._context(task)}"
        )
        response = self._complete(prompt)
        self._log(prompt, response)
        return response


def _run_tests(repo: Path) -> Dict[str, Any]:
    """Execute ``pytest`` in ``repo`` and return output and status."""
    logger.info("running tests in %s", repo)
    proc = subprocess.run(
        ["pytest", "-q"], cwd=repo, capture_output=True, text=True, check=False
    )
    output = proc.stdout + proc.stderr
    log_interaction(
        "pytest",
        {"agent": "tester"},
        {"output": output},
        "ok" if proc.returncode == 0 else "fail",
    )
    return {"returncode": proc.returncode, "output": output}


def _commit(repo: Path, message: str) -> None:
    """Commit current repository state with ``message``."""
    logger.info("committing changes: %s", message)
    subprocess.run(["git", "add", "-A"], cwd=repo, check=False)
    subprocess.run(["git", "commit", "-m", message], cwd=repo, check=False)
    log_interaction(
        "git commit", {"agent": "dev_orchestrator"}, {"message": message}, "ok"
    )


def run_dev_cycle(objective: str, *, repo: str | Path | None = None) -> Dict[str, Any]:
    """Coordinate planning, coding, review, testing and commit for ``objective``."""
    queue: Queue[str] = Queue()
    glm = GLMIntegration()
    repo_path = Path(repo) if repo is not None else None
    planner = Planner("planner", "Plan development tasks", glm, objective, queue)
    coder = Coder("coder", "Write code", glm, objective, queue)
    reviewer = Reviewer("reviewer", "Review code", glm, objective, queue)

    plan_steps = planner.plan()
    results: List[Dict[str, str]] = []
    while not queue.empty():
        task = queue.get()
        code = coder.code(task)
        review = reviewer.review(task, code)
        results.append({"task": task, "code": code, "review": review})

    test_result: Dict[str, Any] | None = None
    if repo_path is not None:
        test_result = _run_tests(repo_path)
        if test_result["returncode"] == 0:
            _commit(repo_path, f"Auto commit: {objective}")

    return {
        "objective": objective,
        "plan": plan_steps,
        "results": results,
        "tests": test_result,
    }


__all__ = ["run_dev_cycle", "Planner", "Coder", "Reviewer", "DevAgent"]

