#!/usr/bin/env python3
"""Command-line utility for running simple pipeline deployments."""
from __future__ import annotations

import argparse
import logging
import subprocess
import sys
from pathlib import Path

import yaml

logger = logging.getLogger(__name__)


def deploy_pipeline(path: str | Path) -> None:
    """Execute each step listed in a pipeline YAML file.

    The YAML must contain a top-level ``steps`` sequence. Each step can be a
    string command or a mapping with a ``run`` key specifying the command.
    Commands are executed sequentially using :func:`subprocess.run`.
    """
    path = Path(path)
    try:
        data = yaml.safe_load(path.read_text()) or {}
    except yaml.YAMLError as exc:
        logger.error("Failed to parse pipeline YAML %s: %s", path, exc)
        raise

    steps = data.get("steps")
    if not isinstance(steps, list):
        raise ValueError("Pipeline YAML must contain a top-level 'steps' list")

    for step in steps:
        command = step if isinstance(step, str) else step.get("run")
        if command:
            try:
                subprocess.run(command, shell=True, check=True)
            except subprocess.CalledProcessError as exc:
                logger.error(
                    "Command failed with exit code %s: %s", exc.returncode, command
                )
                raise


def main(argv: list[str]) -> int:
    """Entry point for the ``spiral_os`` command line interface."""
    parser = argparse.ArgumentParser(prog="spiral_os")
    subparsers = parser.add_subparsers(dest="command")

    pipeline_parser = subparsers.add_parser("pipeline", help="Pipeline operations")
    pipeline_sub = pipeline_parser.add_subparsers(dest="pipeline_cmd")

    deploy_parser = pipeline_sub.add_parser("deploy", help="Run steps from a YAML file")
    deploy_parser.add_argument("yaml", type=Path, help="Path to pipeline YAML file")

    args = parser.parse_args(argv)

    if args.command == "pipeline" and args.pipeline_cmd == "deploy":
        deploy_pipeline(args.yaml)
        return 0

    parser.print_usage()
    return 1


if __name__ == "__main__":
    main(sys.argv[1:])
